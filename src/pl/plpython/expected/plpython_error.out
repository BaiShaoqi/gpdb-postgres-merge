-- test error handling, i forgot to restore Warn_restart in
-- the trigger handler once. the errors and subsequent core dump were
-- interesting.
/* Flat out syntax error
 */
CREATE FUNCTION sql_syntax_error() RETURNS text
        AS
'plpy.execute("syntax error")'
        LANGUAGE plpythonu;
SELECT sql_syntax_error();
<<<<<<< HEAD
ERROR:  plpy.SPIError: syntax error at or near "syntax"
=======
WARNING:  PL/Python: plpy.SPIError: unrecognized error in PLy_spi_execute_query
CONTEXT:  PL/Python function "sql_syntax_error"
ERROR:  syntax error at or near "syntax"
>>>>>>> 1084f317702e1a039696ab8a37caf900e55ec8f2
LINE 1: syntax error
        ^
QUERY:  syntax error
CONTEXT:  Traceback (most recent call last):
  PL/Python function "sql_syntax_error", line 1, in <module>
    plpy.execute("syntax error")
PL/Python function "sql_syntax_error"
/* check the handling of uncaught python exceptions
 */
CREATE FUNCTION exception_index_invalid(text) RETURNS text
	AS
'return args[1]'
	LANGUAGE plpythonu;
SELECT exception_index_invalid('test');
<<<<<<< HEAD
ERROR:  IndexError: list index out of range
CONTEXT:  Traceback (most recent call last):
  PL/Python function "exception_index_invalid", line 1, in <module>
    return args[1]
PL/Python function "exception_index_invalid"
=======
ERROR:  PL/Python: IndexError: list index out of range
CONTEXT:  PL/Python function "exception_index_invalid"
>>>>>>> 1084f317702e1a039696ab8a37caf900e55ec8f2
/* check handling of nested exceptions
 */
CREATE FUNCTION exception_index_invalid_nested() RETURNS text
	AS
'rv = plpy.execute("SELECT test5(''foo'')")
return rv[0]'
	LANGUAGE plpythonu;
SELECT exception_index_invalid_nested();
<<<<<<< HEAD
ERROR:  plpy.SPIError: function test5(unknown) does not exist
=======
WARNING:  PL/Python: plpy.SPIError: unrecognized error in PLy_spi_execute_query
CONTEXT:  PL/Python function "exception_index_invalid_nested"
ERROR:  function test5(unknown) does not exist
>>>>>>> 1084f317702e1a039696ab8a37caf900e55ec8f2
LINE 1: SELECT test5('foo')
               ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
QUERY:  SELECT test5('foo')
CONTEXT:  Traceback (most recent call last):
  PL/Python function "exception_index_invalid_nested", line 1, in <module>
    rv = plpy.execute("SELECT test5('foo')")
PL/Python function "exception_index_invalid_nested"
/* a typo
 */
CREATE FUNCTION invalid_type_uncaught(a text) RETURNS text
	AS
'if "plan" not in SD:
	q = "SELECT fname FROM users WHERE lname = $1"
	SD["plan"] = plpy.prepare(q, [ "test" ])
rv = plpy.execute(SD["plan"], [ a ])
if len(rv):
	return rv[0]["fname"]
return None
'
	LANGUAGE plpythonu;
SELECT invalid_type_uncaught('rick');
<<<<<<< HEAD
ERROR:  plpy.SPIError: type "test" does not exist
CONTEXT:  Traceback (most recent call last):
  PL/Python function "invalid_type_uncaught", line 3, in <module>
    SD["plan"] = plpy.prepare(q, [ "test" ])
PL/Python function "invalid_type_uncaught"
=======
WARNING:  PL/Python: plpy.SPIError: unrecognized error in PLy_spi_prepare
CONTEXT:  PL/Python function "invalid_type_uncaught"
ERROR:  type "test" does not exist
CONTEXT:  PL/Python function "invalid_type_uncaught"
>>>>>>> 1084f317702e1a039696ab8a37caf900e55ec8f2
/* for what it's worth catch the exception generated by
 * the typo, and return None
 */
CREATE FUNCTION invalid_type_caught(a text) RETURNS text
	AS
'if "plan" not in SD:
	q = "SELECT fname FROM users WHERE lname = $1"
	try:
		SD["plan"] = plpy.prepare(q, [ "test" ])
	except plpy.SPIError, ex:
		plpy.notice(str(ex))
		return None
rv = plpy.execute(SD["plan"], [ a ])
if len(rv):
	return rv[0]["fname"]
return None
'
	LANGUAGE plpythonu;
SELECT invalid_type_caught('rick');
<<<<<<< HEAD
NOTICE:  type "test" does not exist
 invalid_type_caught 
---------------------
 
(1 row)

=======
WARNING:  PL/Python: plpy.SPIError: unrecognized error in PLy_spi_prepare
CONTEXT:  PL/Python function "invalid_type_caught"
ERROR:  type "test" does not exist
CONTEXT:  PL/Python function "invalid_type_caught"
>>>>>>> 1084f317702e1a039696ab8a37caf900e55ec8f2
/* for what it's worth catch the exception generated by
 * the typo, and reraise it as a plain error
 */
CREATE FUNCTION invalid_type_reraised(a text) RETURNS text
	AS
'if "plan" not in SD:
	q = "SELECT fname FROM users WHERE lname = $1"
	try:
		SD["plan"] = plpy.prepare(q, [ "test" ])
	except plpy.SPIError, ex:
		plpy.error(str(ex))
rv = plpy.execute(SD["plan"], [ a ])
if len(rv):
	return rv[0]["fname"]
return None
'
	LANGUAGE plpythonu;
SELECT invalid_type_reraised('rick');
<<<<<<< HEAD
ERROR:  plpy.Error: type "test" does not exist
CONTEXT:  Traceback (most recent call last):
  PL/Python function "invalid_type_reraised", line 6, in <module>
    plpy.error(str(ex))
PL/Python function "invalid_type_reraised"
=======
WARNING:  PL/Python: plpy.SPIError: unrecognized error in PLy_spi_prepare
CONTEXT:  PL/Python function "invalid_type_reraised"
ERROR:  type "test" does not exist
CONTEXT:  PL/Python function "invalid_type_reraised"
>>>>>>> 1084f317702e1a039696ab8a37caf900e55ec8f2
/* no typo no messing about
 */
CREATE FUNCTION valid_type(a text) RETURNS text
	AS
'if "plan" not in SD:
	SD["plan"] = plpy.prepare("SELECT fname FROM users WHERE lname = $1", [ "text" ])
rv = plpy.execute(SD["plan"], [ a ])
if len(rv):
	return rv[0]["fname"]
return None
'
	LANGUAGE plpythonu;
SELECT valid_type('rick');
 valid_type 
------------
 
(1 row)

